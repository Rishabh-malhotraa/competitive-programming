Feel free to follow my progress on my main online judge profiles:

<p align="center">
<a href="https: //uhunt.onlinejudge.org/id/1094350"><img src="https://img.shields.io/static/v1?label=uva&message=108&color=green&style=flat-square"></a>
<a href="https: //codeforces.com/profile/brnpapa"><img src="https://img.shields.io/static/v1?label=codeforces&message=79&color=green&style=flat-square"></a>
<a href="https: //www.urionlinejudge.com.br/judge/pt/users/statistics/310281"><img src="https://img.shields.io/static/v1?label=uri&message=69&color=green&style=flat-square"></a>
<a href="https: //www.spoj.com/users/brnpapa"><img src="https://img.shields.io/static/v1?label=spoj&message=42&color=green&style=flat-square"></a>
</p>
<br/>

<h1 align="center">Solutions index</h1>

Â· [#brute-force](#brute-force) Â· [#ad-hoc](#ad-hoc) Â· [#divide-&-conquer](#divide-&-conquer) Â· [#greedy](#greedy) Â· [#geometry](#geometry) Â· [#dynamic-programming](#dynamic-programming) Â· [#math](#math) Â· [#data-structures](#data-structures) Â· [#graphs](#graphs) Â· [#miscellaneous](#miscellaneous) Â· [#strings](#strings) Â·

## strings
- **suffix array**
	- ðŸ˜³ [spoj/SARRAY](./spoj/SARRAY.cpp): `just build a suffix array in O(N * log N)` 

## miscellaneous
- **two pointers**
	- ðŸ˜³ [uva/967](./uva/967.cpp): `pope` 
	- ðŸ™‚ [codeforces/6-C](./codeforces/6-C.cpp) 
	- ðŸ™‚ [codeforces/381-A](./codeforces/381-A.cpp) 
	- ðŸ¥µ [codeforces/1041-D](./codeforces/1041-D.cpp) 
	- ðŸ˜³ [codeforces/279-B](./codeforces/279-B.cpp) 
	- ðŸ˜³ [codeforces/676-C](./codeforces/676-C.cpp) 
- **bitmask**
	- ðŸ™‚ [codeforces/484-A](./codeforces/484-A.cpp) 
- **binary search**
	- ðŸ™‚ [spoj/PAIRS1](./spoj/PAIRS1.cpp): `given the A array, count the quantity of pairs i < j such that A[i]-A[j] == K`  â†’ search on the sorted array A by the A[n]+K, for all n in [0 .. N-1]
	- ðŸ˜³ [codeforces/91-B](./codeforces/91-B.cpp): `given the array a, compute the array d, where d[i] = j-(i+1) for the max j such that a[j] < a[i]`  â†’ apply binary search on preprocessed array mn, filled from right to left
	- ðŸ˜³ [codeforces/1284-B](./codeforces/1284-B.cpp) 
	- ðŸ˜³ [codeforces/1324-D](./codeforces/1324-D.cpp): `given the A and B arrays, count the quantity of pairs i < j such that A[i]+A[j] > B[i]+B[j]`  â†’ diff being the A-B array, count, for all i in [0 .. N-2], how many times -diff[i] < diff[j], for all j in [i+1 .. N-1]
	- **on answer**
		- ðŸ˜³ [uva/12097](./uva/12097.cpp) 
		- ðŸ˜³ [codeforces/1223-C](./codeforces/1223-C.cpp) 
		- ðŸ˜³ [spoj/AGGRCOW](./spoj/AGGRCOW.cpp): `given an array A of size N (2 <= N <= 10^5), print the largest minimum distance between any two of C (C <= N) elements choosen any` 
		- ðŸ¥µ [codeforces/460-C](./codeforces/460-C.cpp) 
		- ðŸ˜³ [uri/2973](./uri/2973.cpp) 

## graphs
- **minimum spanning tree (MST)**
	- ðŸ™‚ [uva/10034](./uva/10034.cpp) 
	- ðŸ™‚ [uva/11710](./uva/11710.cpp) 
	- ðŸ™‚ [spoj/MST](./spoj/MST.cpp) 
	- ðŸ™‚ [uva/1174](./uva/1174.cpp) 
	- **minimum spanning subgraph**
		- ðŸ˜³ [uva/10397](./uva/10397.cpp): `given an implicit complete graph and some edges, compute the cost of the minimum spanning subgraph` 
	- **minimax path**
		- ðŸ˜³ [uva/10099](./uva/10099.cpp): `maximin path; find the minimum cost of the maximum path from s to t`  â†’ apply kruskal to get the maximum spanning tree, but stop it when s and t connect
		- ðŸ™‚ [uva/10048](./uva/10048.cpp) 
- **shortest path**
	- **single-source**
		- **unweighted graph**
			- ðŸ˜³ [uva/12797](./uva/12797.cpp)  â†’ apply a BFS for each subset of letters possible (only 2^10) using bitmask
		- **negative-weighted and cycle graph**
			- ðŸ˜³ [at-coder/ABC137-E](./at-coder/ABC137-E.cpp): `longest distance from 0 to V-1, checking for positive cycle that are part of that path (0 to V-1)` 
		- **weighted graph**
			- ðŸ¥µ [uva/11367](./uva/11367.cpp)  â†’ find the shortest path on state-space graph, where each vertex represent a city and a level of car fuel
			- ðŸ˜³ [uva/11833](./uva/11833.cpp)  â†’ build the graph already with the given constraints
			- ðŸ˜³ [uva/12144](./uva/12144.cpp): `almost shortest path` 
			- ðŸ¥µ [live-archive/3652](./live-archive/3652.cpp): `dijkstra on a given implicit graph as a 2D grid` 
			- ðŸ˜³ [uva/10806](./uva/10806.cpp): `find the global shortest path from 0 to V-1 (round trip), without repeting edges` 
	- **all-pairs**
		- ðŸ™‚ [uri/2372](./uri/2372.cpp) 
- **traversal**
	- ðŸ™‚ [uva/11831](./uva/11831.cpp)  â†’ consider grid as an implicit graph and walk through it, or just rotate the robot, for each received instruction
	- ðŸ˜³ [uva/11906](./uva/11906.cpp)  â†’ consider grid as an implicit graph and walk through it avoiding redundant positions (nr, nc)
	- ðŸ˜³ [code-jam/2020-1A-pascal-walk-TLE](./code-jam/2020-1A-pascal-walk-TLE.cpp) 
	- **edge classification**
		- ðŸ™‚ [codeforces/104-C](./codeforces/104-C.cpp): `check if the given undirected graph can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle`  â†’ check if the graph is connective and has only one cycle
		- ðŸ™‚ [codeforces/510-B](./codeforces/510-B.cpp): `check if a given implicit undirected graph has a cycle of length >= 4` 
	- **flood fill**
		- ðŸ¥µ [uva/1103](./uva/1103.cpp)  â†’ consider each pixel as a vertex of an implicit graph, then identify each hieroglyph counting the number of white CCs within it
		- ðŸ™‚ [uva/11094](./uva/11094.cpp) 
	- **strongly connected components (SCC)**
		- ðŸ˜³ [uva/11504](./uva/11504.cpp)  â†’ count the number of SCCs without incoming edge from a vertex of another SCC
	- **depth-first search (DFS)**
		- ðŸ˜³ [uri/2965](./uri/2965.cpp) 
	- **topological sorting**
		- ðŸ™‚ [uva/11060](./uva/11060.cpp) 
	- **bridges or articulation points**
		- ðŸ¥µ [codeforces/178-B3](./codeforces/178-B3.cpp): `given an undirected graph, count how many bridge edges exists between 2 query vertices`  â†’ group the vertices connected by non-bridge edge during dfs; generate a tree considering each group as a vertice, and using only the bridge edges; find the distance between 2 query vertices of that tree with LCA in O(1)
		- ðŸ¥µ [uva/12363](./uva/12363.cpp): `given an undirected graph, check if there is a unique path between 2 query vertices`  â†’ there is a unique path between s and t if the path between them is formed only by bridge edges; for optimize, keep sets for the vertices that are on the same connected component in the pruned graph (with only bridge edges)
		- ðŸ™‚ [uva/796](./uva/796.cpp) 
- **maximum flow**
	- ðŸ˜³ [uva/10779](./uva/10779.cpp)  â†’ each friend receives 1 flow unit of a sticker and offers a flow of other sticker; Bob also offers, but he receives 1 flow unit of each sticker; maximized it
	- ðŸ™‚ [uva/820](./uva/820.cpp) 
	- **minimum cost**
		- ðŸ™‚ [uva/10594](./uva/10594.cpp) 
- **specials**
	- ðŸ˜³ [uva/12442](./uva/12442.cpp): `given a graph with all vertices with out-degree 1, find the vertice that reaches the most vertices` 
	- **directed acyclic graph (DAG)**
		- ðŸ™‚ [uva/988](./uva/988.cpp): `counting paths from 0 to V-1` 
	- **tree**
		- ðŸ™‚ [spoj/LABYR1](./spoj/LABYR1.cpp): `compute the diameter of a given implicit tree` 
		- ðŸ˜³ [spoj/ONP](./spoj/ONP.cpp): `infix to postfix conversion`  â†’ see that the given expression is the in-order traversal in a binary tree, then print post-order traversal recursively without building the tree
		- ðŸ™‚ [codeforces/115-A](./codeforces/115-A.cpp): `given a forest, find the length of the longest path` 
		- **lowest common ancestor (LCA)**
			- ðŸ˜³ [uva/12238](./uva/12238.cpp): `given a weighted tree, find the distance between 2 query vertices` 
			- ðŸ™‚ [timus/1471](./timus/1471.cpp): `given a weighted tree, find the distance between 2 query vertices` 
	- **bipartite**
		- **bipartite checking**
			- ðŸ™‚ [spoj/BUGLIFE](./spoj/BUGLIFE.cpp)  â†’ check all connect components
			- ðŸ™‚ [uva/10004](./uva/10004.cpp) 
		- **max cardinality bipartite matching**
			- ðŸ˜³ [uva/10080](./uva/10080.cpp): `max number of preys that can hide safely from an predator attack`  â†’ consider a bipartite graph with edges that connect a gopher (prey) to an reachable hole
			- ðŸ˜³ [uva/11262](./uva/11262.cpp)  â†’ binary search on answer + MCBM

## data structures
- **sparse table**
	- ðŸ™‚ [spoj/THRBL](./spoj/THRBL.cpp): `range max query` 
- **segment tree**
	- ðŸ™‚ [live-archive/6139](./live-archive/6139.cpp): `range product query` 
	- ðŸ™‚ [codeforces/339-D](./codeforces/339-D.cpp) 
	- **lazy propagation**
		- ðŸ˜³ [uri/2658](./uri/2658.cpp)  â†’ build a segment tree for RSQ, but store an array of size 9 in tree[v], where tree[v][n] indicates the frequency that the note n appears in that interval
		- ðŸ˜³ [uva/11402](./uva/11402.cpp)  â†’ build a segment tree for RSQ, but keep in lazy[v] the type of pending operation to be performed in that interval of A
- **union-find disjoint sets (UFDS)**
	- ðŸ™‚ [uva/11966](./uva/11966.cpp) 
	- ðŸ™‚ [codeforces/445-B](./codeforces/445-B.cpp)  â†’ 2 ^ (sum of (size of set - 1), for each disjoint set)
	- ðŸ™‚ [uva/10608](./uva/10608.cpp) 
	- ðŸ™‚ [codeforces/1249-B2](./codeforces/1249-B2.cpp) 
	- ðŸ˜³ [codeforces/25-D](./codeforces/25-D.cpp) 

## math
- **game theory**
	- **minimax**
		- ðŸ˜³ [uva/12484](./uva/12484.cpp): `alberto and wanderley take one of two cards at the edges of the cards sequence, alberto want maximize it`  â†’ fill memo table in row-major order
		- ðŸ˜³ [uva/10111](./uva/10111.cpp): `given a state of a tic tac toe board, check if X will win independent of the O movement`  â†’ minimax + memo + backtracking
		- **optimized**
			- ðŸ¥µ [uva/847](./uva/847.cpp): `multiplication game`  â†’ note that if Stan always multiply by 9 and Ollie by 2, it's still an optimal solution
- **number theory**
	- ðŸ˜³ [uri/2291](./uri/2291.cpp): `print n-th divine number, the one that is equal to the sum of the sum of each divisor from 1 to n`  â†’ think like sieve
	- ðŸ˜³ [uva/547](./uva/547.cpp): `find the longest DDF sequence`  â†’ pre-process a array f, where f[i] is the sum of digits of all positive factors of i; think like sieve
	- **greatest common divisor (GCD)**
		- ðŸ˜³ [codeforces/75-C](./codeforces/75-C.cpp): `find the gcd(a, b) that is in a query range [lo .. hi]`  â†’ note that all divisors of gcd(a, b) are also divisors of a and b
		- ðŸ™‚ [codeforces/854-A](./codeforces/854-A.cpp): `given n, determine maximum possible proper (a < b) and irreducible fraction a/b such that a+b == n` 
		- ðŸ™‚ [codeforces/822-A](./codeforces/822-A.cpp) 
	- **module arithmetic**
		- ðŸ™‚ [uva/10176](./uva/10176.cpp): `is a given binary number of 100 digits divisible by 131071?` 
		- ðŸ™‚ [uva/374](./uva/374.cpp): `compute (a^n) % m, where a <= 2^31 and n <= 2^31`  â†’ use fast power with mod
	- **prime numbers**
		- ðŸ™‚ [spoj/PRIONPRI](./spoj/PRIONPRI.cpp): `prime checking` 
		- **prime factorization**
			- ðŸ™‚ [uva/10042](./uva/10042.cpp) 
			- ðŸ˜³ [uva/10139](./uva/10139.cpp): `do n! is divisible by m?`  â†’ check if the prime factors of m are contained in the prime factors of n!
			- ðŸ¥µ [uri/2661](./uri/2661.cpp): `compute the number of divisors of n that can be written as the product of two or more distinct prime numbers (without repetition), 1 <= n <= 10^12`  â†’ note that the product of any combination of prime factors of a number will always be a divisor of that number
		- **sieve of eratosthenes**
			- ðŸ˜³ [codeforces/576-A](./codeforces/576-A.cpp) 
			- ðŸ™‚ [spoj/AMR11E](./spoj/AMR11E.cpp): `print the n-th number that has at least 3 distinct prime factors`  â†’ use modified sieve
			- ðŸ™‚ [codeforces/230-B](./codeforces/230-B.cpp): `check if a large n has exactily three distinct positive divisors`  â†’ check if sqrt(n) is prime
			- ðŸ˜³ [uva/10539](./uva/10539.cpp): `compute the quantity of non-prime numbers in [lo .. hi] which are divisible by only a single prime number, 0 < lo <= hi < 10^12`  â†’ generate all powers of each prime number
			- ðŸ˜³ [spoj/PRIME1](./spoj/PRIME1.cpp): `print all primes p in [m .. n], 0 <= m <= n <= 10^9, n-m <= 10^5`  â†’ sieve + prime checking
- **matrix exponentiation**
	- ðŸ™‚ [uva/10229](./uva/10229.cpp)  â†’ transform the fibonacci recurrence into a matrix exponentiation
- **ad-hoc**
	- ðŸ™‚ [uva/10812](./uva/10812.cpp) 
	- ðŸ™‚ [codeforces/16-C](./codeforces/16-C.cpp) 
	- ðŸ™‚ [uva/10346](./uva/10346.cpp) 
	- ðŸ™‚ [uva/12791](./uva/12791.cpp) 
	- ðŸ™‚ [codeforces/1042-A](./codeforces/1042-A.cpp) 
	- ðŸ™‚ [uva/11875](./uva/11875.cpp) 
	- ðŸ™‚ [uva/10110](./uva/10110.cpp): `check if the number of divisors of n is odd`  â†’ check if n is a perfect square
	- ðŸ™‚ [uva/11723](./uva/11723.cpp) 
	- ðŸ˜³ [codeforces/573-A](./codeforces/573-A.cpp) 
	- **finding pattern**
		- ðŸ™‚ [codeforces/1221-C](./codeforces/1221-C.cpp) 
		- ðŸ˜³ [uva/10161](./uva/10161.cpp) 
		- ðŸ™‚ [codeforces/1324-A](./codeforces/1324-A.cpp) 
		- ðŸ˜³ [codeforces/1092-D1](./codeforces/1092-D1.cpp)  â†’ remove adjacent ones whose absolute difference is even (using a stack)
		- ðŸ™‚ [spoj/EIGHTS](./spoj/EIGHTS.cpp) 
		- ðŸ¥µ [uva/11718](./uva/11718.cpp)  â†’ compute K * N^(K-1) * sumA using fast power mod
	- **sequences**
		- ðŸ˜³ [uva/443](./uva/443.cpp) 
		- ðŸ¥µ [uva/10706](./uva/10706.cpp)  â†’ pre-process the number sequence and f(k), so use binary search on f
		- ðŸ˜³ [uva/264](./uva/264.cpp)  â†’ use binary search on preprocessed f(x)=f(x-1)+x-1
	- **arithmetic progression**
		- ðŸ˜³ [uva/11254](./uva/11254.cpp) 
- **combinatorics**
	- ðŸ™‚ [codeforces/131-B](./codeforces/131-B.cpp) 
	- ðŸ™‚ [codeforces/459-B](./codeforces/459-B.cpp): `find the max difference between numbers of a given array and the number of ways to get it` 
	- **combinations**
		- **binomial coefficient**
			- ðŸ™‚ [codeforces/844-B](./codeforces/844-B.cpp) 
			- ðŸ¥µ [uri/2972](./uri/2972.cpp): `calculate the sum of C(N, k)%2 for all k in [0 .. n], i.e., how many odd combinations of k heads between n coins there are`  â†’ just compute 2^qtyBitsOn(n)
		- **multi-combinations**
			- ðŸ˜³ [codeforces/630-G](./codeforces/630-G.cpp)  â†’ C(n+5-1,5) * C(n+3-1,3)

## dynamic programming
- ðŸ˜³ [codeforces/1061-C](./codeforces/1061-C.cpp)  â†’ use space saving + all divisors in O(sqrt(n)) to optimize
- ðŸ™‚ [uva/11000](./uva/11000.cpp) 
- ðŸ˜³ [uva/10651](./uva/10651.cpp)  â†’ use bitmask
- ðŸ™‚ [uva/10943](./uva/10943.cpp) 
- ðŸ™‚ [uva/10911](./uva/10911.cpp)  â†’ use bitmasks
- ðŸ˜³ [codeforces/166-E](./codeforces/166-E.cpp) 
- ðŸ™‚ [spoj/RPLB](./spoj/RPLB.cpp) 
- ðŸ˜³ [uva/10721](./uva/10721.cpp) 
- ðŸ™‚ [uva/10003](./uva/10003.cpp) 
- ðŸ™‚ [spoj/LINEUP](./spoj/LINEUP.cpp)  â†’ use bitmask
- ðŸ™‚ [uva/10337](./uva/10337.cpp) 
- ðŸ™‚ [spoj/TRT](./spoj/TRT.cpp)  â†’ don't memoize the current day
- ðŸ™‚ [uva/11450](./uva/11450.cpp) 
- **longest increasing subsequence (LIS)**
	- ðŸ˜³ [uri/1517](./uri/1517.cpp) 
	- ðŸ˜³ [uva/10131](./uva/10131.cpp)  â†’ sort elephants based on increasing kg, then apply LDS on iq
	- ðŸ˜³ [uva/11456](./uva/11456.cpp)  â†’ find the max(lis[i]+lds[i]-1) for all i in [0 .. N-1], being i where the subsequence starts
	- ðŸ¥µ [uva/481](./uva/481.cpp) 
- **coin change**
	- ðŸ™‚ [uva/11407](./uva/11407.cpp)  â†’ consider the coins as the perfect squares
	- ðŸ˜³ [uva/166](./uva/166.cpp): `coin change with limited amount of coins + greedy coin change with unlimited amount of coins; I don't know why, but it works without memo` 
	- ðŸ™‚ [codeforces/189-A](./codeforces/189-A.cpp) 
- **0-1 knapsack**
	- ðŸ™‚ [spoj/SCUBADIV](./spoj/SCUBADIV.cpp) 
	- ðŸ™‚ [spoj/KNAPSACK](./spoj/KNAPSACK.cpp) 
	- ðŸ˜³ [spoj/FISHER](./spoj/FISHER.cpp): `get the (min) total value and total weight of the optimal knapsack` 
	- ðŸ™‚ [uri/2498](./uri/2498.cpp) 
	- ðŸ˜³ [uri/1487](./uri/1487.cpp) 
	- ðŸ˜³ [uva/10261](./uva/10261.cpp): `as if there were 2 knapsacks to fill at the same time; with recovering` 
	- ðŸ™‚ [uva/990](./uva/990.cpp): `with recovering` 
- **max 2D range sum**
	- ðŸ¥µ [uva/10755](./uva/10755.cpp): `max 3D range sum`  â†’ use max 2D range sum in two of the three dimensions and max 1D range sum (kadane) on the third dimension
	- ðŸ™‚ [uva/108](./uva/108.cpp) 
- **digit**
	- ðŸ˜³ [uri/1707](./uri/1707.cpp): `given two numbers x and y, compute the sum of the decimal digits of the odd numbers in the range [min(x,y) .. max(x,y)]` 
	- ðŸ™‚ [spoj/CPCRC1C](./spoj/CPCRC1C.cpp) 
- **max 1D range sum**
	- **kadane**
		- ðŸ™‚ [uva/10684](./uva/10684.cpp) 
		- ðŸ™‚ [spoj/MAXSUMSU](./spoj/MAXSUMSU.cpp) 
		- ðŸ™‚ [codeforces/1285-B](./codeforces/1285-B.cpp) 
- **subset sum**
	- ðŸ˜³ [uva/10616](./uva/10616.cpp): `given an array of size N, count how many subsets of size M have their sum divisible by D`  â†’ use module arithmetic
	- ðŸ™‚ [uri/1203](./uri/1203.cpp): `check if any subset of A has a sum equal to K` 
	- ðŸ˜³ [uri/2089](./uri/2089.cpp)  â†’ optimize memory
	- ðŸ™‚ [uva/624](./uva/624.cpp): `print the subset of A with the max sum k, k <= K` 
	- ðŸ˜³ [uva/11658](./uva/11658.cpp): `find the smallest sum s of a subset of A, s >= S`  â†’ scan as %d.%d
	- **with repetition**
		- ðŸ™‚ [uva/674](./uva/674.cpp) 
		- ðŸ™‚ [uva/11137](./uva/11137.cpp) 
		- ðŸ™‚ [uva/357](./uva/357.cpp) 
- **traveling salesman problem (TSP)**
	- ðŸ™‚ [uva/10496](./uva/10496.cpp) 
	- ðŸ˜³ [uva/116](./uva/116.cpp) 
- **longest common subsequence (LCS)**
	- ðŸ™‚ [spoj/IOIPALIN](./spoj/IOIPALIN.cpp): `given a string, determine the minimal quantity of characters to be inserted into it in order to obtain a palindrome`  â†’ compute length of string minus lcs between string and reversed string
	- ðŸ™‚ [spoj/ADASEQEN](./spoj/ADASEQEN.cpp) 
- **LCS reduced to LIS**
	- ðŸ˜³ [uva/10635](./uva/10635.cpp) 

## geometry
- ðŸ™‚ [uva/11152](./uva/11152.cpp) 
- ðŸ™‚ [spoj/GOALFR](./spoj/GOALFR.cpp) 
- ðŸ™‚ [codeforces/499-C](./codeforces/499-C.cpp)  â†’ count how many lines the 2 points cross
- ðŸ™‚ [codeforces/1047-B](./codeforces/1047-B.cpp) 
- ðŸ™‚ [codeforces/659-D](./codeforces/659-D.cpp) 

## greedy
- ðŸ™‚ [uva/10954](./uva/10954.cpp): `add all` 
- ðŸ™‚ [codeforces/1092-B](./codeforces/1092-B.cpp) 
- ðŸ™‚ [code-jam/2020-QR-nesting-depth](./code-jam/2020-QR-nesting-depth.cpp) 
- ðŸ˜³ [codeforces/204-B](./codeforces/204-B.cpp): `given the two-sided values of N cards, what is the minimum number of turns in the cards so that at least half of them are the same front?; they are initially facing upwards` 
- ðŸ™‚ [uva/11491](./uva/11491.cpp): `remove D digits from the given number, in a such way that the remain number is maximum` 
- ðŸ˜³ [uva/11240](./uva/11240.cpp): `length of the longest inc/dec (alternating) subsequence` 
- ðŸ™‚ [codeforces/275-C](./codeforces/275-C.cpp) 
- ðŸ™‚ [spoj/GERGOVIA](./spoj/GERGOVIA.cpp) 
- ðŸ˜³ [code-jam/2020-1A-pattern-matching](./code-jam/2020-1A-pattern-matching.cpp) 
- ðŸ™‚ [spoj/SNGINT](./spoj/SNGINT.cpp): `given an integer n, find the smallest positive integer m > 0 such that the product of digits of m equals n` 
- ðŸ™‚ [spoj/CADYDIST](./spoj/CADYDIST.cpp) 
- ðŸ˜³ [codeforces/1237-C2](./codeforces/1237-C2.cpp)  â†’ sort the points, remove pairs with equal x and y first, then pairs with equal x and finally the rest
- ðŸ™‚ [codeforces/1257-A](./codeforces/1257-A.cpp) 
- ðŸ™‚ [codeforces/1324-C](./codeforces/1324-C.cpp)  â†’ note that it's unnecessary jump to the left, so to minimize d, just jump between the nearest 'R' cells
- ðŸ™‚ [code-jam/2020-QR-parenting-partnering-returns](./code-jam/2020-QR-parenting-partnering-returns.cpp) 
- ðŸ™‚ [spoj/BUSYMAN](./spoj/BUSYMAN.cpp): `compute the maximum number of activities (each with start and end times) that you can do without overlapping them (one at a time)`  â†’ sort the activites by increasing end time
- ðŸ™‚ [codeforces/1324-B](./codeforces/1324-B.cpp): `given a sequence of integers, is there a subsequence palindrome of size 3?`  â†’ check if there are two equal non-adjacent numbers using brute force
- ðŸ™‚ [codeforces/545-D](./codeforces/545-D.cpp) 
- ðŸ™‚ [codeforces/984-A](./codeforces/984-A.cpp) 
- ðŸ™‚ [codeforces/1360-C](./codeforces/1360-C.cpp) 
- **bipartite matching**
	- ðŸ™‚ [uva/11292](./uva/11292.cpp) 
- **restrict coin change**
	- ðŸ™‚ [codeforces/1255-A](./codeforces/1255-A.cpp) 
- **interval covering**
	- ðŸ˜³ [uva/10382](./uva/10382.cpp)  â†’ reduce the problem using pythagoras to one line
- **loading balance**
	- ðŸ™‚ [uva/11389](./uva/11389.cpp) 
	- ðŸ˜³ [uri/1055](./uri/1055.cpp) 

## divide & conquer
- ðŸ˜³ [codeforces/768-B](./codeforces/768-B.cpp)  â†’ knowing the size of the final array with a little math, use the same idea to query a range in a segment tree

## ad-hoc
- ðŸ™‚ [spoj/ADAQUEUE](./spoj/ADAQUEUE.cpp) 
- ðŸ™‚ [codeforces/1220-A](./codeforces/1220-A.cpp) 
- ðŸ™‚ [uri/2963](./uri/2963.cpp) 
- ðŸ™‚ [uri/2968](./uri/2968.cpp) 
- ðŸ™‚ [spoj/SBANK](./spoj/SBANK.cpp) 
- ðŸ™‚ [uri/3024](./uri/3024.cpp) 
- ðŸ™‚ [codeforces/1285-A](./codeforces/1285-A.cpp) 
- ðŸ™‚ [spoj/EC_CONB](./spoj/EC_CONB.cpp) 
- ðŸ™‚ [uva/10141](./uva/10141.cpp) 
- ðŸ™‚ [uva/12015](./uva/12015.cpp) 
- ðŸ™‚ [codeforces/37-A](./codeforces/37-A.cpp) 
- ðŸ™‚ [code-jam/2020-1C-overexcited-fan](./code-jam/2020-1C-overexcited-fan.cpp) 
- ðŸ™‚ [uva/12798](./uva/12798.cpp) 
- ðŸ¥µ [uri/1368](./uri/1368.cpp) 
- ðŸ™‚ [codeforces/151-A](./codeforces/151-A.cpp) 
- ðŸ™‚ [uri/2884](./uri/2884.cpp) 
- ðŸ™‚ [uri/2879](./uri/2879.cpp) 
- ðŸ™‚ [uva/11799](./uva/11799.cpp) 
- ðŸ™‚ [uri/2242](./uri/2242.cpp) 
- **implementation**
	- ðŸ™‚ [codeforces/811-B](./codeforces/811-B.cpp) 
	- ðŸ™‚ [spoj/GNY07D](./spoj/GNY07D.cpp) 
	- ðŸ˜³ [uri/2971](./uri/2971.cpp) 
	- ðŸ™‚ [uva/105](./uva/105.cpp): `skyline` 
	- ðŸ™‚ [codeforces/373-A](./codeforces/373-A.cpp) 
	- ðŸ™‚ [code-jam/2020-QR-vestigium](./code-jam/2020-QR-vestigium.cpp) 
	- ðŸ™‚ [codeforces/1284-A](./codeforces/1284-A.cpp) 
	- ðŸ˜³ [codeforces/1296-C](./codeforces/1296-C.cpp)  â†’ maps each position of the robot with the string index, and check if a new position has already been mapped before
	- ðŸ™‚ [codeforces/492-B](./codeforces/492-B.cpp) 
	- ðŸ™‚ [uri/2593](./uri/2593.cpp) 
	- ðŸ™‚ [codeforces/110-A](./codeforces/110-A.cpp) 
	- ðŸ˜³ [codeforces/1254-A](./codeforces/1254-A.cpp) 
	- ðŸ˜³ [codeforces/519-C](./codeforces/519-C.cpp) 
	- ðŸ™‚ [uri/1975](./uri/1975.cpp) 
	- ðŸ™‚ [uri/1215](./uri/1215.cpp) 
	- ðŸ™‚ [codeforces/266-A](./codeforces/266-A.cpp) 
	- ðŸ™‚ [codeforces/81-A](./codeforces/81-A.cpp) 
	- ðŸ™‚ [uri/1261](./uri/1261.cpp) 
	- ðŸ™‚ [uri/1260](./uri/1260.cpp) 
	- ðŸ™‚ [uri/1763](./uri/1763.cpp) 
	- ðŸ™‚ [codeforces/158-C](./codeforces/158-C.cpp) 

## brute force
- **recursive backtracking**
	- ðŸ™‚ [uva/10344](./uva/10344.cpp): `check if some arithmetic expression of 5 given numbers will result in 23`  â†’ check all combination of operators for each permutation of the given numbers
	- ðŸ™‚ [code-jam/2020-QR-indicium-TLE](./code-jam/2020-QR-indicium-TLE.cpp): `generate M, where M[i][j] is any value in [1 .. N] (2 <= N <= 5), but without repeting a value in same line or column, and with the sum of the main diagonal equal to K` 
	- ðŸ˜³ [uva/10503](./uva/10503.cpp): `given domino pieces, check if it is possible to arrive at a target piece from an initial piece using N intermediate pieces (possibly rotating them)`  â†’ DFS + backtracking
	- ðŸ™‚ [spoj/MKJUMPS](./spoj/MKJUMPS.cpp): `given an unweighted implicit graph, count the longest possible path`  â†’ DFS + backtracking
	- ðŸ™‚ [live-archive/2883](./live-archive/2883.cpp): `chess with a single horse against up to 8 pawns; print the length of the minimum sequence of horse moves if it wins` 
	- **n-queens**
		- ðŸ˜³ [uva/11195](./uva/11195.cpp)  â†’ use bitmask
	- **pruned permutations**
		- ðŸ˜³ [uva/524](./uva/524.cpp) 
		- ðŸ™‚ [spoj/BTCK](./spoj/BTCK.cpp) 
	- **sudoku**
		- ðŸ™‚ [uva/989](./uva/989.cpp) 
- **iterative**
	- ðŸ˜³ [uva/12792](./uva/12792.cpp): `simulation`  â†’ note that if you 'watch' a unique card, the full deck will become sorted as soon as this card reaches its original position
	- ðŸ™‚ [uva/12801](./uva/12801.cpp) 
	- ðŸ™‚ [codeforces/633-A](./codeforces/633-A.cpp): `check if a diophantine equation has positive solution` 
	- ðŸ™‚ [uva/628](./uva/628.cpp) 
	- ðŸ™‚ [uva/10360](./uva/10360.cpp) 
	- ðŸ™‚ [uva/725](./uva/725.cpp) 
	- **all subsets**
		- ðŸ™‚ [codeforces/550-B](./codeforces/550-B.cpp)  â†’ use bitmask
		- ðŸ™‚ [uva/12455](./uva/12455.cpp)  â†’ use bitmask
	- **all permutations**
		- ðŸ™‚ [uva/750](./uva/750.cpp) 
